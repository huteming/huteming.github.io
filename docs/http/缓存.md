## 强缓存

强缓存，在缓存数据未失效的情况下，客户端可以直接使用缓存数据，不用和数据库进行交互。

那么，判断请求是否失效主要靠两个 HTTP Header：

`Expires`: 数据的缓存到期时间，下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。

`Cache-Control`: 可以指定一个 `max-age` 字段，表示缓存的内容将在一定时间后失效。

## 协商缓存

协商缓存，顾名思义需要和服务器进行一次协商。浏览器第一次请求时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。

再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。

判断请求主要靠下面两组 HTTP Header：

`Last-Modified`: 一个 `Response Header`，服务器在响应请求时，告诉浏览器资源的最后修改时间。

`if-Modified-Since`: 一个 `Request Header`，再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。

服务器会通过收到的 `If-Modified-Since` 和资源的最后修改时间进行比对，判断是否使用缓存。

`Etag`: 一个 `Response Header`，服务器返回的资源的唯一标示

`If-None-Match`: 一个 `Request Header`，再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。

服务器会通过收到的 `If-None-Match` 和资源的唯一标识进行对比，判断是否使用缓存。

## Last-Modified

### 优点

1. 不存在版本问题

### 缺点

1. **只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回给客户端**。例如周期性重写，这种情况下该资源包含的数据实际上是一样的；
2. 以时刻作为标识，**无法识别一秒内进行多次修改的情况**。如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒；
3. 某些服务器**不能精确的得到文件最后修改时间**；如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用

## Etag

### 优点

1. 可以更加精确的判断资源是否被修改

### 缺点

1. 计算 Etag 值**需要性能损耗**;
2. 分布式服务器时**依赖算法**：分布式服务器存储的情况下，计算 Etag 的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现 Etag 不匹配的情况。
