<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http | 特明的日志</title>
    <meta name="description" content="关于 HTTP 的一些基础知识">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.7f63faaf.css" as="style"><link rel="preload" href="/assets/js/app.f913f9d4.js" as="script"><link rel="preload" href="/assets/js/6.7ebaf463.js" as="script"><link rel="preload" href="/assets/js/4.af9338ed.js" as="script"><link rel="preload" href="/assets/js/36.e0001180.js" as="script"><link rel="prefetch" href="/assets/js/1.2ea39911.js"><link rel="prefetch" href="/assets/js/10.7814a16a.js"><link rel="prefetch" href="/assets/js/11.1a4b8928.js"><link rel="prefetch" href="/assets/js/12.100a1a10.js"><link rel="prefetch" href="/assets/js/13.1ecf7c4a.js"><link rel="prefetch" href="/assets/js/14.cd66458a.js"><link rel="prefetch" href="/assets/js/15.79f54e90.js"><link rel="prefetch" href="/assets/js/16.4ed9d7e2.js"><link rel="prefetch" href="/assets/js/17.99f28218.js"><link rel="prefetch" href="/assets/js/18.eced304a.js"><link rel="prefetch" href="/assets/js/19.6c5626d7.js"><link rel="prefetch" href="/assets/js/20.dc5afa1f.js"><link rel="prefetch" href="/assets/js/21.803e0f31.js"><link rel="prefetch" href="/assets/js/22.e1579b99.js"><link rel="prefetch" href="/assets/js/23.7b413778.js"><link rel="prefetch" href="/assets/js/24.8cfd9c52.js"><link rel="prefetch" href="/assets/js/25.20c14f78.js"><link rel="prefetch" href="/assets/js/26.141777bd.js"><link rel="prefetch" href="/assets/js/27.b706cecf.js"><link rel="prefetch" href="/assets/js/28.3d1f27c4.js"><link rel="prefetch" href="/assets/js/29.7a30e9af.js"><link rel="prefetch" href="/assets/js/30.73b85e87.js"><link rel="prefetch" href="/assets/js/31.623dcf40.js"><link rel="prefetch" href="/assets/js/32.d564fb82.js"><link rel="prefetch" href="/assets/js/33.d7be1f48.js"><link rel="prefetch" href="/assets/js/34.5e0b04a1.js"><link rel="prefetch" href="/assets/js/35.716047e7.js"><link rel="prefetch" href="/assets/js/37.4680380a.js"><link rel="prefetch" href="/assets/js/38.38469638.js"><link rel="prefetch" href="/assets/js/39.b3e32c88.js"><link rel="prefetch" href="/assets/js/40.ed4928ef.js"><link rel="prefetch" href="/assets/js/41.518609f3.js"><link rel="prefetch" href="/assets/js/42.8f3e635e.js"><link rel="prefetch" href="/assets/js/43.ed5ca0b7.js"><link rel="prefetch" href="/assets/js/5.edb5ba7a.js"><link rel="prefetch" href="/assets/js/7.5fd9a5cc.js"><link rel="prefetch" href="/assets/js/8.404a9741.js"><link rel="prefetch" href="/assets/js/9.c1b70d79.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.73fe3575.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7f63faaf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">特明的日志 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">编程</a></li><li class="nav-item"><a href="/react/" class="nav-link">react</a></li><li class="nav-item"><a href="/algorithm/" class="nav-link">算法</a></li><li class="nav-item"><a href="/knowledge/" class="nav-link router-link-active">知识点</a></li><li class="nav-item"><a href="/tools/" class="nav-link">工具指南</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">特明的日志 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">编程</a></li><li class="mobile-nav-item"><a href="/react/" class="nav-link">react</a></li><li class="mobile-nav-item"><a href="/algorithm/" class="nav-link">算法</a></li><li class="mobile-nav-item"><a href="/knowledge/" class="nav-link router-link-active">知识点</a></li><li class="mobile-nav-item"><a href="/tools/" class="nav-link">工具指南</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        http
      </h1> <div class="post-meta"><!----> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-05-12T00:00:00.000Z">
      2020-05-12
    </time></div> <!----></div></header> <div itemprop="articleBody" class="content__default"><h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <p>HTTP 是<strong>超文本传输协议</strong>，也就是 <code>HyperText Transfer Protocol</code>。</p> <p>翻译成大白话:</p> <p>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p> <h2 id="常见状态码"><a href="#常见状态码" class="header-anchor">#</a> 常见状态码</h2> <h4 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h4> <p>属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p> <h4 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h4> <p>表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p> <ul><li><p>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p></li> <li><p>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p></li> <li><p>「206 Partial Content」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p></li></ul> <h4 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h4> <p>表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p> <ul><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li> <li><p>「302 Moved Permanently」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p></li></ul> <blockquote><p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p></blockquote> <ul><li>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li></ul> <h4 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h4> <p>表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p> <ul><li><p>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</p></li> <li><p>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</p></li> <li><p>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p></li></ul> <h4 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h4> <p>表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p> <ul><li><p>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</p></li> <li><p>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</p></li> <li><p>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p></li> <li><p>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</p></li></ul> <h2 id="常见字段"><a href="#常见字段" class="header-anchor">#</a> 常见字段</h2> <ul><li>Host</li></ul> <p>客户端发送请求时，用来指定服务器的域名。</p> <ul><li>Connection</li></ul> <p>Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</p> <p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 keep-alive。</p> <div class="language- extra-class"><pre class="language-text"><code>Connection: keep-alive
</code></pre></div><p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p> <ul><li>Content-Length</li></ul> <p>服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。</p> <ul><li>Content-Type</li></ul> <p>Content-Type 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Type: text/html; charset=utf-8
</code></pre></div><p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p> <p>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式。</p> <div class="language- extra-class"><pre class="language-text"><code>Accept: */*
</code></pre></div><p>上面代码中，客户端声明自己可以接受任何格式的数据。</p> <ul><li>Content-Encoding</li></ul> <p>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</p> <div class="language- extra-class"><pre class="language-text"><code>Content-Encoding: gzip
</code></pre></div><p>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p> <p>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法。</p> <div class="language- extra-class"><pre class="language-text"><code>Accept-Encoding: gzip, deflate
</code></pre></div><h2 id="get-post"><a href="#get-post" class="header-anchor">#</a> GET &amp; POST</h2> <h3 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> get 和 post 的区别</h3> <p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。</p> <p>POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p> <h3 id="是安全且幂等的吗"><a href="#是安全且幂等的吗" class="header-anchor">#</a> 是安全且幂等的吗</h3> <div class="custom-block tip"><p class="custom-block-title">安全和幂等</p> <p>在 HTTP 协议里，</p> <p>所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</p> <p>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p></div> <p>很明显 GET 方法就是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。</p> <p>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p> <h2 id="http-特性"><a href="#http-特性" class="header-anchor">#</a> HTTP 特性</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p> <h4 id="_1-简单"><a href="#_1-简单" class="header-anchor">#</a> 1. 简单</h4> <p>HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</p> <h4 id="_2-灵活和易于扩展"><a href="#_2-灵活和易于扩展" class="header-anchor">#</a> 2. 灵活和易于扩展</h4> <p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。</p> <p>同时 HTTP 由于是工作在应用层（ OSI 第七层），则它下层可以随意变化。</p> <p>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层</p> <h4 id="_3-应用广泛和跨平台"><a href="#_3-应用广泛和跨平台" class="header-anchor">#</a> 3. 应用广泛和跨平台</h4> <p>互联网发展至今，HTTP 的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP，从看新闻、刷贴吧到购物、理财、吃鸡，HTTP 的应用片地开花，同时天然具有跨平台的优越性。</p> <h3 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h3> <p>HTTP 协议里有优缺点一体的双刃剑，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p> <h4 id="_1-无状态双刃剑"><a href="#_1-无状态双刃剑" class="header-anchor">#</a> 1. 无状态双刃剑</h4> <p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p> <p>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p> <p>例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息。</p> <p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 Cookie 技术。</p> <p>Cookie 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p> <h4 id="_2-明文传输双刃剑"><a href="#_2-明文传输双刃剑" class="header-anchor">#</a> 2. 明文传输双刃剑</h4> <p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p> <p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取</p> <h4 id="_3-不安全"><a href="#_3-不安全" class="header-anchor">#</a> 3. 不安全</h4> <p>HTTP 比较严重的缺点就是不安全：</p> <ul><li><p>通信使用明文（不加密），内容可能会被窃听。</p></li> <li><p>不验证通信方的身份，因此有可能遭遇伪装。</p></li> <li><p>无法证明报文的完整性，所以有可能已遭篡改</p></li></ul> <p>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</p> <h3 id="性能"><a href="#性能" class="header-anchor">#</a> 性能</h3> <h4 id="_1-长连接"><a href="#_1-长连接" class="header-anchor">#</a> 1. 长连接</h4> <p>早期 HTTP/1.0 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。</p> <p>为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p> <p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p> <h4 id="_2-管道网络传输"><a href="#_2-管道网络传输" class="header-anchor">#</a> 2. 管道网络传输</h4> <p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p> <p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p> <p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p> <p>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「<strong>队头堵塞</strong>」。</p> <h4 id="_3-队头阻塞"><a href="#_3-队头阻塞" class="header-anchor">#</a> 3. 队头阻塞</h4> <p>「请求 - 应答」的模式加剧了 HTTP 的性能问题。</p> <p>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「队头阻塞」。好比上班的路上塞车。</p> <p>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能。</p> <h2 id="http-与-https"><a href="#http-与-https" class="header-anchor">#</a> HTTP 与 HTTPS</h2> <h3 id="http-与-https-有哪些区别？"><a href="#http-与-https-有哪些区别？" class="header-anchor">#</a> HTTP 与 HTTPS 有哪些区别？</h3> <ol><li><p>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</p></li> <li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p></li> <li><p>HTTP 的端口号是 80，HTTPS 的端口号是 443。</p></li> <li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li></ol> <h3 id="https-解决了-http-的哪些问题？"><a href="#https-解决了-http-的哪些问题？" class="header-anchor">#</a> HTTPS 解决了 HTTP 的哪些问题？</h3> <p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p> <ul><li><p>窃听风险，比如通信链路上可以获取通信内容。</p></li> <li><p>篡改风险，比如强制入垃圾广告，视觉污染。</p></li> <li><p>冒充风险，比如冒充淘宝网站。</p></li></ul> <h3 id="https-是如何解决上面的三个风险的？"><a href="#https-是如何解决上面的三个风险的？" class="header-anchor">#</a> HTTPS 是如何解决上面的三个风险的？</h3> <ul><li><p>混合加密的方式实现信息的机密性，解决了窃听的风险。</p></li> <li><p>摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</p></li> <li><p>将服务器公钥放入到数字证书中，解决了冒充的风险。</p></li></ul> <h4 id="_1-混合加密"><a href="#_1-混合加密" class="header-anchor">#</a> 1. 混合加密</h4> <p>通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。</p> <p>HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</p> <ul><li><p>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</p></li> <li><p>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</p></li></ul> <div class="custom-block tip"><p class="custom-block-title">采用「混合加密」的方式的原因：</p> <p>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</p> <p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</p></div> <h4 id="_2-摘要算法"><a href="#_2-摘要算法" class="header-anchor">#</a> 2. 摘要算法</h4> <p>摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p> <p>校验完整性
校验完整性
客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同
加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。</p> <h4 id="_3-数字证书"><a href="#_3-数字证书" class="header-anchor">#</a> 3. 数字证书</h4> <p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p> <p>这就存在些问题，如何保证公钥不被篡改和信任度？</p> <p>所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p> <p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p> <h3 id="tcp-三次握手"><a href="#tcp-三次握手" class="header-anchor">#</a> TCP 三次握手</h3> <p>（1）客户端发起一个带有建立连接标示的包，包中包含一个客户端生成的一个序列号（seq=x）</p> <p>（2）服务端接收到这个包之后，会回复一个带有建立连接标示和确认标示的包，其中包含一个服务端生成的序列号（seq=y）和一个确认号码（ack=x+1）</p> <p>（3）客户端收到之后，会再回复一个包，这个包带有确认标示，和一个确认号码（ack=y+1）</p> <h3 id="tcp-四次挥手"><a href="#tcp-四次挥手" class="header-anchor">#</a> TCP 四次挥手</h3> <p>（1）客户端发起一个带有结束标示的包，包中带有一个序列号（seq=x）</p> <p>（2）服务端收到后，但此时服务端可能还没有准备好断开连接，所以会先发送一个带有确认标示的包，包中带有确认序号（ack=x+1）</p> <p>（3）等到服务端可以断开连接之后，会想客户端发送一个带有结束标示的包，带有序列号（seq=y）</p> <p>（4）客户端收到服务端的这个结束标示的包之后，会回复一个带有确认标示的包，确认号码为ack=y+1</p> <h3 id="ssl-tls-协议建立的详细流程："><a href="#ssl-tls-协议建立的详细流程：" class="header-anchor">#</a> SSL/TLS 协议建立的详细流程：</h3> <h4 id="_1-clienthello"><a href="#_1-clienthello" class="header-anchor">#</a> 1. ClientHello</h4> <p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。</p> <p>在这一步，客户端主要向服务器发送以下信息：</p> <p>（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。</p> <p>（2）客户端支持的密码套件列表，如 RSA 加密算法。</p> <p>（3）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。</p> <h4 id="_2-severhello"><a href="#_2-severhello" class="header-anchor">#</a> 2. SeverHello</h4> <p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：</p> <p>（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p> <p>（2）确认的密码套件列表，如 RSA 加密算法。</p> <p>（3）服务器的数字证书。</p> <p>（4）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。</p> <h4 id="_3-客户端回应"><a href="#_3-客户端回应" class="header-anchor">#</a> 3.客户端回应</h4> <p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p> <p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p> <p>（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。</p> <p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> <p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p> <p>上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p> <h4 id="_4-服务器的最后回应"><a href="#_4-服务器的最后回应" class="header-anchor">#</a> 4. 服务器的最后回应</h4> <p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：</p> <p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p> <p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p> <p>至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p> <h2 id="http-1-1、http-2-演变"><a href="#http-1-1、http-2-演变" class="header-anchor">#</a> HTTP/1.1、HTTP/2 演变</h2> <h3 id="说说-http-1-1-相比-http-1-0-提高了什么性能？"><a href="#说说-http-1-1-相比-http-1-0-提高了什么性能？" class="header-anchor">#</a> 说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3> <p>HTTP/1.1 相比 HTTP/1.0 性能上的改进：</p> <p>（1）使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</p> <p>（2）支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p> <p>但 HTTP/1.1 还是有性能瓶颈：</p> <p>（1）请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</p> <p>（2）发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</p> <p>（3）服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</p> <p>（4）没有请求优先级控制；</p> <p>（5）请求只能从客户端开始，服务器只能被动响应。</p> <h3 id="http-2-做了什么优化？"><a href="#http-2-做了什么优化？" class="header-anchor">#</a> HTTP/2 做了什么优化？</h3> <p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p> <p>那 HTTP/2 相比 HTTP/1.1 性能上的改进：</p> <h4 id="_1-头部压缩"><a href="#_1-头部压缩" class="header-anchor">#</a> 1. 头部压缩</h4> <p>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</p> <p>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p> <h4 id="_2-二进制格式"><a href="#_2-二进制格式" class="header-anchor">#</a> 2. 二进制格式</h4> <p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</p> <p>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。</p> <p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</p> <h4 id="_3-数据流"><a href="#_3-数据流" class="header-anchor">#</a> 3. 数据流</h4> <p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p> <p>每个请求或回应的所有数据包，称为一个数据流（Stream）。</p> <p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p> <p>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p> <h4 id="_4-多路复用"><a href="#_4-多路复用" class="header-anchor">#</a> 4. 多路复用</h4> <p>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</p> <p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</p> <p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p> <h4 id="_5-服务器推送"><a href="#_5-服务器推送" class="header-anchor">#</a> 5. 服务器推送</h4> <p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p> <p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#基本概念" title="基本概念">基本概念</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#常见状态码" title="常见状态码">常见状态码</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#常见字段" title="常见字段">常见字段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#get-post" title="GET &amp; POST">GET &amp; POST</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#get-和-post-的区别" title="get 和 post 的区别">get 和 post 的区别</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#是安全且幂等的吗" title="是安全且幂等的吗">是安全且幂等的吗</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#http-特性" title="HTTP 特性">HTTP 特性</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#优点" title="优点">优点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#缺点" title="缺点">缺点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#性能" title="性能">性能</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#http-与-https" title="HTTP 与 HTTPS">HTTP 与 HTTPS</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#http-与-https-有哪些区别？" title="HTTP 与 HTTPS 有哪些区别？">HTTP 与 HTTPS 有哪些区别？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#https-解决了-http-的哪些问题？" title="HTTPS 解决了 HTTP 的哪些问题？">HTTPS 解决了 HTTP 的哪些问题？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#https-是如何解决上面的三个风险的？" title="HTTPS 是如何解决上面的三个风险的？">HTTPS 是如何解决上面的三个风险的？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#tcp-三次握手" title="TCP 三次握手">TCP 三次握手</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#tcp-四次挥手" title="TCP 四次挥手">TCP 四次挥手</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#ssl-tls-协议建立的详细流程：" title="SSL/TLS 协议建立的详细流程：">SSL/TLS 协议建立的详细流程：</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#http-1-1、http-2-演变" title="HTTP/1.1、HTTP/2 演变">HTTP/1.1、HTTP/2 演变</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#说说-http-1-1-相比-http-1-0-提高了什么性能？" title="说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？">说说 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#http-2-做了什么优化？" title="HTTP/2 做了什么优化？">HTTP/2 做了什么优化？</a></div></div></div></div> <footer class="footer" data-v-fdbf4940><div class="footer-left-wrap" data-v-fdbf4940><ul class="contact" data-v-fdbf4940></ul></div> <div class="footer-right-wrap" data-v-fdbf4940><ul class="copyright" data-v-fdbf4940></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f913f9d4.js" defer></script><script src="/assets/js/6.7ebaf463.js" defer></script><script src="/assets/js/4.af9338ed.js" defer></script><script src="/assets/js/36.e0001180.js" defer></script>
  </body>
</html>
