---
title: 正则表达式
tags: [正则表达式]
---

正则入门知识整理，原文在[这里](https://juejin.cn/post/6844903487155732494)。

<!--truncate-->

## 字符匹配

### 1. 两种模糊匹配

#### 1.1 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

其实现的方式是使用量词。譬如`{m,n}`，表示连续出现最少 m 次，最多 n 次。

#### 1.2 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。

其实现的方式是使用字符组。譬如`[abc]`，表示该字符是可以字符“a”、“b”、“c”中的任何一个。

### 2. 字符组

#### 2.1 范围表示法

比如`[123456abcdefGHIJKLM]`，可以写成`[1-6a-fG-M]`。用连字符-来省略和简写

#### 2.2 排除字符组

例如`[^abc]`，表示是一个除"a"、"b"、"c"之外的任意一个字符。字符组的第一位放`^`（脱字符），表示求反的概念。

#### 2.3 常见的简写形式

有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。

:::tip
\d 就是[0-9]。表示是一位数字。记忆方式：其英文是 digit（数字）。

\D 就是`[^0-9]`。表示除数字外的任意字符。

\w 就是`[0-9a-zA-Z_]`。表示数字、大小写字母和下划线。记忆方式：w 是 word 的简写，也称单词字符。

\W 是`[^0-9a-zA-Z_]`。非单词字符。

\s 是`[\t\v\n\r\f]`。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。记忆方式：s 是 space character 的首字母。

\S 是`[^\t\v\n\r\f]`。 非空白符。`.`就是`[^\n\r\u2028\u2029]`。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。记忆方式：想想省略号...中的每个点，都可以理解成占位符，表示任何类似的东西。
:::

如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。

### 3. 量词

量词也称重复。掌握`{m,n}`的准确含义后，只需要记住一些简写形式。

#### 3.1 简写形式

:::tip
`{m,}` 表示至少出现 m 次。

`{m}` 等价于{m,m}，表示出现 m 次。

`?` 等价于{0,1}，表示出现或者不出现。

`+` 等价于{1,}，表示出现至少一次。

`*` 等价于{0,}，表示出现任意次，有可能不出现。
:::

#### 3.2 贪婪匹配和惰性匹配

看如下的例子：

```js
var regex = /\d{2,5}/g
var string = '123 1234 12345 123456'
console.log(string.match(regex))
// => ["123", "1234", "12345", "12345"]
```

其中正则`/\d{2,5}/`，表示数字连续出现 2 到 5 次。会匹配 2 位、3 位、4 位、5 位连续数字。

但是其是贪婪的，它会尽可能多的匹配。你能给我 6 个，我就要 5 个。你能给我 3 个，我就 3 要个。反正只要在能力范围内，越多越好。

而惰性匹配，就是尽可能少的匹配：

```js
var regex = /\d{2,5}?/g
var string = '123 1234 12345 123456'
console.log(string.match(regex))
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```

其中`/\d{2,5}?/`表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不在往下尝试了。

通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：

:::tip
{m,n}?

{m,}?

??

+?

\*?
:::

### 4. 多选分支

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

具体形式如下：`(p1|p2|p3)`，其中`p1`、`p2`和`p3`是子模式，用`|`（管道符）分隔，表示其中任何之一。

例如要匹配"good"和"nice"可以使用`/good|nice/`。测试如下：

```js
var regex = /good|nice/g
var string = 'good idea, nice try.'
console.log(string.match(regex))
// => ["good", "nice"]
```

但有个事实我们应该注意，比如我用`/good|goodbye/`，去匹配"goodbye"字符串时，结果是"good"：

```js
var regex = /good|goodbye/g
var string = 'goodbye'
console.log(string.match(regex))
// => ["good"]
```

而把正则改成`/goodbye|good/`，结果是：

```js
var regex = /goodbye|good/g
var string = 'goodbye'
console.log(string.match(regex))
// => ["goodbye"]
```

**也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。**

## 位置匹配

### 1. 什么是位置呢

位置是相邻字符之间的位置。比如，下图中箭头所指的地方：

![hello](/img/blog/reg-position.png)

### 2. 如何匹配位置呢？

在 ES5 中，共有 6 个锚字符：

> `^` `$` `\b` `\B` `(?=p)` `(?!p)`

#### 2.1 ^和$

`^`（脱字符）匹配开头，在多行匹配中匹配行开头。

`$`（美元符号）匹配结尾，在多行匹配中匹配行结尾。

#### 2.2 \b 和\B

`\b`是单词边界，具体就是`\w`和`\W`之间的位置，也包括`\w`和`^`之间的位置，也包括`\w`和`$`之间的位置。

`\B`就是`\b`的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉`\b`，剩下的都是`\B`的。

#### 2.3 (?=p)和(?!p)

`(?=p)`其中 p 是一个子模式，即`p`前面的位置。比如`(?=l)`，表示'l'字符前面的位置，例如：

```js
var result = 'hello'.replace(/(?=l)/g, '#')
console.log(result)
// => "he#l#lo"
```

而`(?!p)`就是`(?=p)`的反面意思，比如：

```js
var result = 'hello'.replace(/(?!l)/g, '#')

console.log(result)
// => "#h#ell#o#"
```

二者的学名分别是 positive lookahead 和 negative lookahead

ES6 中，还支持 positive lookbehind 和 negative lookbehind。

具体是`(?<=p)`和`(?<!p)`

### 3. 位置的特性

对于位置的理解，我们可以理解成空字符""。

比如"hello"字符串等价于如下的形式：

```js
'hello' == '' + 'h' + '' + 'e' + '' + 'l' + '' + 'l' + 'o' + ''
```

甚至可以写成更复杂的:

```js
var result = /(?=he)^^he(?=\w)llo$\b\b$/.test('hello')
console.log(result)
// => true
```

也就是说字符之间的位置，可以写成多个。

**把位置理解空字符，是对位置非常有效的理解方式。**

### 4. 相关案例

1. 要求这个位置不是开头？

- 匹配开头可以使用`^`，不是开头可以使用`(?!^)`

2. 要求的必须包含数字

- 此时我们可以使用`(?=.*[0-9])`来做。

## 小括号的作用

### 1. 分组和分支结构

#### 1.1 分组

我们知道`/a+/`匹配连续出现的“a”，而要匹配连续出现的“ab”时，需要使用`/(ab)+/`。

#### 1.2 分支结构

而在多选分支结构`(p1|p2)`中，此处括号提供了子表达式的所有可能。

### 2. 引用分组

这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。

#### 2.1 提取数据

比如提取出年、月、日，可以这么做：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'
console.log(string.match(regex))
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

另外也可以使用正则对象的 exec 方法：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'
console.log(regex.exec(string))
// => ["2017-06-12", "2017", "06", "12", index: 0, input: "2017-06-12"]
```

同时，也可以使用构造函数的全局属性`$1`至`$9`来获取：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'

regex.test(string) // 正则操作即可，例如
//regex.exec(string);
//string.match(regex);

console.log(RegExp.$1) // "2017"
console.log(RegExp.$2) // "06"
console.log(RegExp.$3) // "12"
```

#### 2.2 替换

比如，想把 yyyy-mm-dd 格式，替换成 mm/dd/yyyy 怎么做？

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'
var result = string.replace(regex, '$2/$3/$1')
console.log(result)
// => "06/12/2017"
```

其中`replace`中的，第二个参数里用`$1`、`$2`、`$3`指代相应的分组。等价于如下的形式：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'
var result = string.replace(regex, function () {
  return RegExp.$2 + '/' + RegExp.$3 + '/' + RegExp.$1
})
console.log(result)
// => "06/12/2017"
```

也等价于：

```js
var regex = /(\d{4})-(\d{2})-(\d{2})/
var string = '2017-06-12'
var result = string.replace(regex, function (match, year, month, day) {
  return month + '/' + day + '/' + year
})
console.log(result)
// => "06/12/2017"
```

### 3. 反向引用

除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。

比如要写一个正则支持匹配如下三种格式：

:::note
2016-06-12

2016/06/12

2016.06.12
:::

最先可能想到的正则是:

```js
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/
var string1 = '2017-06-12'
var string2 = '2017/06/12'
var string3 = '2017.06.12'
var string4 = '2016-06/12'
console.log(regex.test(string1)) // true
console.log(regex.test(string2)) // true
console.log(regex.test(string3)) // true
console.log(regex.test(string4)) // true
```

其中`/`和`.`需要转义。虽然匹配了要求的情况，但也匹配"2016-06/12"这样的数据。

假设我们想要求分割符前后一致怎么办？此时需要使用反向引用：

```js
var regex = /\d{4}(-|\/|\.)\d{2}\1\d{2}/
var string1 = '2017-06-12'
var string2 = '2017/06/12'
var string3 = '2017.06.12'
var string4 = '2016-06/12'
console.log(regex.test(string1)) // true
console.log(regex.test(string2)) // true
console.log(regex.test(string3)) // true
console.log(regex.test(string4)) // false
```

#### 3.1 括号嵌套怎么办？

以左括号（开括号）为准。比如：

```js
var regex = /^((\d)(\d(\d)))\1\2\3\4$/
var string = '1231231233'
console.log(regex.test(string)) // true
console.log(RegExp.$1) // 123
console.log(RegExp.$2) // 1
console.log(RegExp.$3) // 23
console.log(RegExp.$4) // 3
```

#### 3.2 10 表示什么呢？

另外一个疑问可能是，即`\10`是表示第 10 个分组，还是`\1`和`0`呢？答案是前者，虽然一个正则里出现`\10`比较罕见。测试如下：

```js
var regex = /(1)(2)(3)(4)(5)(6)(7)(8)(9)(#) \10+/
var string = '123456789# ######'
console.log(regex.test(string))
// => true
```

#### 3.3 引用不存在的分组会怎样？

因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配反向引用的字符本身。例如`\2`，就匹配"\2"。注意"\2"表示对"2"进行了转意。

```js
var regex = /\1\2\3\4\5\6\7\8\9/
console.log(regex.test('\1\2\3\4\5\6\789')) // true
console.log('\1\2\3\4\5\6\789'.split(''))
```

### 4. 非捕获分组

之前文中出现的分组，都会捕获它们匹配到的数据，以便后续引用，因此也称他们是捕获型分组。

如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获分组`(?:p)`，例如本文第一个例子可以修改为：

```js
var regex = /(?:ab)+/g
var string = 'ababa abbb ababab'
console.log(string.match(regex))
// => ["abab", "ab", "ababab"]
```

## 正则表达式编程

### 1. 正则表达式的四种操作

正则表达式是匹配模式，不管如何使用正则表达式，万变不离其宗，都需要先“匹配”。

有了匹配这一基本操作后，才有其他的操作：验证、切分、提取、替换。

#### 1.1 验证

- 使用 search

```js
var regex = /\d/
var string = 'abc123'
console.log(!!~string.search(regex))
// => true
```

- 使用 test

```js
var regex = /\d/
var string = 'abc123'
console.log(regex.test(string))
// => true
```

- 使用 match

```js
var regex = /\d/
var string = 'abc123'
console.log(!!string.match(regex))
// => true
```

- 使用 exec

```js
var regex = /\d/
var string = 'abc123'
console.log(!!regex.exec(string))
// => true
```

#### 1.2 切分

比如，目标字符串是"html,css,javascript"，按逗号来切分：

```js
var regex = /,/
var string = 'html,css,javascript'
console.log(string.split(regex))
// => ["html", "css", "javascript"]
```

“切出”年月日：

```js
var regex = /\D/
console.log('2017/06/26'.split(regex))
console.log('2017.06.26'.split(regex))
console.log('2017-06-26'.split(regex))
// => ["2017", "06", "26"]
// => ["2017", "06", "26"]
// => ["2017", "06", "26"]
```

#### 1.3 提取

提取出年月日。注意下面正则中的括号：

- match

```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/
var string = '2017-06-26'
console.log(string.match(regex))
// =>["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]
```

- exec

```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/
var string = '2017-06-26'
console.log(regex.exec(string))
// =>["2017-06-26", "2017", "06", "26", index: 0, input: "2017-06-26"]
```

- test

```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/
var string = '2017-06-26'
regex.test(string)
console.log(RegExp.$1, RegExp.$2, RegExp.$3)
// => "2017" "06" "26"
```

- search

```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/
var string = '2017-06-26'
string.search(regex)
console.log(RegExp.$1, RegExp.$2, RegExp.$3)
// => "2017" "06" "26"
```

- replace

```js
var regex = /^(\d{4})\D(\d{2})\D(\d{2})$/
var string = '2017-06-26'
var date = []
string.replace(regex, function (match, year, month, day) {
  date.push(year, month, day)
})
console.log(date)
// => ["2017", "06", "26"]
```

#### 1.4 替换

从 yyyy-mm-dd 替换成 yyyy/mm/dd：

```js
var string = '2017-06-26'
var today = new Date(string.replace(/-/g, '/'))
console.log(today)
// => Mon Jun 26 2017 00:00:00 GMT+0800 (中国标准时间)
```

### 2. 相关 API 注意要点

从上面可以看出用于正则操作的方法，共有 6 个，字符串实例 4 个，正则实例 2 个：

:::note
String#search

String#split

String#match

String#replace

RegExp#test

RegExp#exec
:::

#### 2.1 search 和 match 的参数问题

我们知道字符串实例的那 4 个方法参数都支持正则和字符串。但`search`和`match`，会把字符串转换为正则的。

```js
var string = '2017.06.27'

console.log(string.search('.'))
// => 0
//需要修改成下列形式之一
console.log(string.search('\\.'))
console.log(string.search(/\./))
// => 4
// => 4

console.log(string.match('.'))
// => ["2", index: 0, input: "2017.06.27"]
//需要修改成下列形式之一
console.log(string.match('\\.'))
console.log(string.match(/\./))
// => [".", index: 4, input: "2017.06.27"]
// => [".", index: 4, input: "2017.06.27"]

console.log(string.split('.'))
// => ["2017", "06", "27"]

console.log(string.replace('.', '/'))
// => "2017/06.27"
```
