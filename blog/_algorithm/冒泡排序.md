---
title: 冒泡排序
summary: 冒泡排序
date: 2021-03-29
---

---

## 简介

冒泡排序之所以叫冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动

冒泡排序是一种稳定排序，值相等的元素并不会打乱原本的顺序。由于该排序算法的每一轮都要遍历所有元素，总共遍历(元素数量-1)轮，所以平均时间复杂 度是 O(n2)。

### 思想

把相邻的元素两两比较，当一个元素大于右侧相 邻元素时，交换它们的位置;当一个元素小于或等于右侧相邻元素时，位置不变

## 第一版

```js
function sortArray(nums) {
  const b = nums.concat();

  for (let i = 0; i < b.length - 1; i++) {
    for (let j = 0; j < b.length - i - 1; j++) {
      if (b[j] > b[j + 1]) {
        const temp = b[j];
        b[j] = b[j + 1];
        b[j + 1] = temp;
      }
    }
  }

  return b;
}
```

### 问题

经过几轮排序后，整个数列可能已经是有序的了，但是该实现还是兢兢业业的继续完成了所有的排序，

在这种情况下，如果能判断数据已经有序，并做出标记，可以提前结束工作

## 第二版

```js
function sortArray(nums) {
  const b = nums.concat();

  for (let i = 0; i < b.length - 1; i++) {
    let isSorted = true;

    for (let j = 0; j < b.length - 1 - i; j++) {
      if (b[j] > b[j + 1]) {
        const temp = b[j];
        b[j] = b[j + 1];
        b[j + 1] = temp;
        isSorted = false;
      }
    }
    // 如果没有进行元素交换，说明已经完成排序
    if (isSorted) {
      return b;
    }
  }

  return b;
}
```

### 问题

按照现有的逻辑，有序区的长度和排序的轮数是相等的。例如第 1 轮排序过后的 有序区长度是 1，第 2 轮排序过后的有序区长度是 2 ......

实际上，数列真正的有序区可能会大于这个长度，如上述例子中在第 2 轮排序 时，后面的 5 个元素实际上都已经属于有序区了。因此后面的多次元素比较是没有意 义的。

那么，我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，再往后就是有序区了。

## 第三版

```js
function sortArray(nums) {
  const b = nums.concat();
  let sortBoard1 = b.length - 1;
  let lastChangeIndex = 0;

  for (let i = 0; i < b.length - 1; i++) {
    let isSorted = true;

    for (let j = 0; j < sortBoard1; j++) {
      if (b[j] > b[j + 1]) {
        const temp = b[j];
        b[j] = b[j + 1];
        b[j + 1] = temp;
        isSorted = false;
        lastChangeIndex = j;
      }
    }
    // 每一轮交换结束后，根据最后的交换位置缩小比较区间
    sortBoard1 = lastChangeIndex;
    // 如果没有进行元素交换，说明已经完成排序
    if (isSorted) {
      return b;
    }
  }

  return b;
}
```

### 问题

算法的每一轮都是从左到右来比较元素，进行单向的位置交换 的

如果现在有一个数组是这样的 [2, 3, 4, 5, 1]

元素 2、3、4、5 已经是有序的了，但因为 1 的位置不对，却还要进行 4 轮。

可以利用双向的比较和交换过程来解决这个问题

## 第四版(最终版)

```js
function sortArray(nums) {
  const b = nums.concat();
  let sortBoard1 = b.length - 1;
  let sortBoard2 = 0;
  let lastChangeIndex = 0;

  for (let i = 0; i < b.length / 2; i++) {
    let isSorted = true;

    for (let j = sortBoard2; j < sortBoard1; j++) {
      if (b[j] > b[j + 1]) {
        const temp = b[j];
        b[j] = b[j + 1];
        b[j + 1] = temp;
        isSorted = false;
        lastChangeIndex = j;
      }
    }
    // 每一轮交换结束后，根据最后的交换位置缩小比较区间
    sortBoard1 = lastChangeIndex;
    // 如果没有进行元素交换，说明已经完成排序
    if (isSorted) {
      return b;
    }

    isSorted = true;
    for (let j = sortBoard1; j > sortBoard2; j--) {
      if (b[j - 1] > b[j]) {
        const temp = b[j - 1];
        b[j - 1] = b[j];
        b[j] = temp;
        isSorted = false;
        lastChangeIndex = j;
      }
    }
    sortBoard2 = lastChangeIndex;
    if (isSorted) {
      return b;
    }
  }

  return b;
}
```
