---
title: 斐波那契数列
summary: 每日算法之斐波那契数列
date: 2020-05-02
---

## 题目描述

要求输入一个整数n，输出斐波那契数列的第n项（从0开始，第0项为0;答案需要取模 1e9 + 7（1000000007））。

### 提示

1. 基本解法是递归，注意避免递归的缺陷

2. 可以使用动态规划解法

### 递归解法

::: tip 尾调用优化
关于尾调用优化，可以看[这篇文章](https://www.ruanyifeng.com/blog/2015/04/tail-call.html)
:::

```js
// !!! 这个解法会造成爆栈
// 如果不需要取模，可以用该解法
function calc (n) {
  if (n < 2) {
    return n
  }
  return (calc(n - 1) + calc(n - 2)) % 1000000007
}
// 因为会有重复计算，可以利用一个数组缓存结果
function calc (n, memory = []) {
  if (n < 2) {
    return n
  }
  if (!memory[n]) {
    memory[n] = (calc(n - 1, memory) + calc(n - 2, memory)) % 1000000007
  }
  return memory[n]
}
```

```js
// 正确的递归解法，尾递归优化
function calc (n, a = 1, b = 1) {
  if (n < 2) {
    return n
  }
  if (n === 2) {
    return b
  }
  return calc(n - 1, b, (a + b) % 1000000007)
}
```

### 动态规划解法

::: tip 动态规划
- 动态规划有时被认为是一种与递归相反的技术，是因为递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个整体解决方案，从而解决掉整个大问题。

- （有待验证）使用递归去解决问题虽然简洁，但效率不高。包括 JavaScript 在内的众多语言，不能高效地将递归代码解释为机器代码，尽管写出来的程序简洁，但是执行效率低下。但这并不是说使用递归是件坏事，本质上说，只是那些指令式编程语言和面向对象的编程语言对递归 的实现不够完善，因为它们没有将递归作为高级编程的特性。
:::

```js
function calc (n) {
  if (n < 2) {
    return n
  }
  let a = 0
  let b = 1
  let res = 0
  for (let i = 2; i <= n; i++) {
    res = (a + b) % 1000000007
    a = b
    b = res
  }
  return res
}
```
