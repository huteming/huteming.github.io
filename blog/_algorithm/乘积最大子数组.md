---
title: 乘积最大子数组
summary: 每日算法之乘积最大子数组
date: 2020-05-18
---

## 题目

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

### 示例

示例 1:

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

## 题解

### 思路

这个题目和和最大子数组的最大区别是：**当前位置的最优解未必是由前一个位置的最优解转移得到的**

因为可能存在负负得正的情况。

用f(x)表示以下标x结尾的乘积最大子数组的乘积，用num[x]表示下标为x的数。用这里正确的思路应该是：

1. 当x为负数时，我们希望f(x-1)也是一个负数，而且越小越好，这样f(x-1) * num(x) 的乘积才能最大

2. 当x为正数时，我们希望f(x-1)是一个正数，而且越大越好，这样f(x-1) * num(x) 的乘积才能最大

3. 综上，我们在计算以下标x结尾的乘积最大子数组的乘积时，不仅需要前一项的乘积最大值，还要知道前一项的乘积最小值

### 代码实现

```js
function maxProduct (nums) {
  let minNum = nums[0]
  let maxNum = nums[0]
  let result = nums[0]

  for (let i = 1; i < nums.length; i++) {
    const current = nums[i]
    let _minNum = minNum
    let _maxNum = maxNum
    // 注意，计算最大值最小值时，必须和current做比较
    // 比如：当前一项的最大值，最小值都是0时，当前值才是最大（最小）值
    minNum = Math.min(_minNum * current, _maxNum * current, current)
    maxNum = Math.max(_minNum * current, _maxNum * current, current)
    result = Math.max(maxNum, result)
  }

  return result
}
```


