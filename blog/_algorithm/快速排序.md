---
title: 快速排序
summary: 快速排序
date: 2021-03-31
---

---

## 思路

基本思想是将待排序列分为两半，左边的一半总是“小的”，右边的一半总是“大的”，这一过程不断递归持续下去，直到整个序列有序

::: tip 题外话
快速排序是很重要的算法，是二十世纪十大算法之一
:::

### 基准元素的选择

最简单的方式是选择数列的第1个元素。

种选择在绝大多数情况下是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列。这时候整个数列并没有被分成两半，每一轮都只确定了基准元素的位置，这时候，快速排序的时间复杂度退化成了O(n2)

解决办法也很简答，可以随机选择一个元素作为基准元素，并且让基准元素和数 列首元素交换位置。

::: tip 了解
即使是随机选择基准元素，也会有极小的几率选到数列的最大值或最小值，同样会影响分治的效果。

所以，虽然快速排序的平均时间复杂度是O(nlogn)，但最坏情况下的时间复杂度 是O(n2)。
:::

### 元素的变换

#### 双边循环

1. 首先，选定基准元素pivot，并且设置两个指针left和right，指向数列的最左 和最右两个元素。

2. 接下来进行第1次循环，从right指针开始，让指针所指向的元素和基准元素做 比较。如果大于或等于pivot，则指针向左移动;如果小于pivot，则right指针停 止移动，切换到left指针。

3. 轮到left指针行动，让指针所指向的元素和基准元素做比较。如果小于或等于pivot，则指针向右移动;如果大于pivot，则left指针停止移动。

4. 这时，让left和right指针所指向的元 素进行交换。

5. 接下来无限循环步骤2和步骤3，不停的移动left 和 right 指针，直到他们相遇重合，再把它和基准元素交换，以这个位置为基准，分为左右两个数组

6. 然后就是不停的递归排序之前获得的数组，直到整个数组都是有序的

#### 单边循环

1. 首先选定基准元素pivot。同时，设置一个mark指针 指向数列起始位置，这个mark指针代表小于基准元素的区域边界。

2. 接下来，从基准元素的下一个位置开始遍历数组。如果遍历到的元素大于基准元素，就继续往后遍历。

3. 如果遍历到的元素小于基准元素，则需要做两件事:第一，把mark指针右移1 位，因为小于pivot的区域边界增大了1;第二，让最新遍历到的元素和mark指针所 在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。

4. 遍历结束之后，把基准元素换到 mark 指针所在位置，此时，以基准元素为基准，分为左右两个数组

5. 然后就是不停的递归排序之前获得的数组，直到整个数组都是有序的

## code

### 双边循环

```js
function exchange (nums, i, j) {
  const temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}

function part (nums, startIndex, endIndex) {
  const target = nums[startIndex]
  let left = startIndex
  let right = endIndex

  while (left < right) {
    while (right > left && nums[right] > target) {
      right--
    }

    while (left < right && nums[left] <= target) {
      left++
    }

    if (left < right) {
      exchange(nums, left, right)
    }
  }

  exchange(nums, startIndex, left)
  return left
}

function core (nums, startIndex, endIndex) {
  if (startIndex >= endIndex) {
    return
  }
  const partIndex = part(nums, startIndex, endIndex)
  core(nums, startIndex, partIndex - 1)
  core(nums, partIndex + 1, endIndex)
}

function sort (nums) {
  const startIndex = 0
  const endIndex = nums.length - 1
  const copyNums = nums.concat()
  core(copyNums, startIndex, endIndex)
  return copyNums
}
```

### 单边循环

```js
function exchange (nums, i, j) {
  const temp = nums[i]
  nums[i] = nums[j]
  nums[j] = temp
}

function part (nums, startIndex, endIndex) {
  const target = nums[startIndex]
  let mark = startIndex

  for (let i = startIndex + 1; i <= endIndex; i++) {
    if (nums[i] <= target) {
      mark++
      exchange(nums, i, mark)
    }
  }

  exchange(nums, startIndex, mark)
  return mark
}

function core (nums, startIndex, endIndex) {
  if (startIndex >= endIndex) {
    return
  }
  const partIndex = part(nums, startIndex, endIndex)
  core(nums, startIndex, partIndex - 1)
  core(nums, partIndex + 1, endIndex)
}

function sort (nums) {
  const copyNums = nums.concat()
  const startIndex = 0
  const endIndex = nums.length - 1
  core(copyNums, startIndex, endIndex)
  return copyNums
}
```

## 优化

上面的代码都是用的递归的方式，但递归其实基本都是可以转化成一个栈的实现，下面以 `单边循环` 中的 `core` 方法为例，用栈来代替递归实现

```js
function coreStack (nums, startIndex, endIndex) {
  if (startIndex >= endIndex) {
    return
  }
  const args = [[startIndex, endIndex]]

  while (args.length) {
    const [start, end] = args.shift()
    const partIndex = part(nums, start, end)
    if (start < partIndex - 1) {
      args.push([start, partIndex - 1])
    }
    if (partIndex + 1 < end) {
      args.push([partIndex + 1, end])
    }
  }
}
```
