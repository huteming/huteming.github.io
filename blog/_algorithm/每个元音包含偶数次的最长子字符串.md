---
title: 每个元音包含偶数次的最长子字符串
summary: 每日算法之每个元音包含偶数次的最长子字符串
date: 2020-05-20
---

## 题目

给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 'a'，'e'，'i'，'o'，'u' ，在子字符串中都恰好出现了偶数次。

### 示例

示例 1：

```
输入：s = "eleetminicoworoep"
输出：13
解释：最长子字符串是 "leetminicowor" ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。
```

示例 2：

```
输入：s = "leetcodeisgreat"
输出：5
解释：最长子字符串是 "leetc" ，其中包含 2 个 e 。
```

示例 3：

```
输入：s = "bcbcbc"
输出：6
解释：这个示例中，字符串 "bcbcbc" 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。
```

## 题解

### 思路

对于数组的题目，在不可避免要全部遍历的情况下，总是希望能够一边遍历一边更新结果。

也就是需要在遍历过程中求出以当前位置结束最优解。

**1. 当前位置最优解**

假设当前位置各个元音出现次数是： a,e 出现奇数次；i,o,u 出现偶数次。

那么最优解一定是：当前下标i - 最早出现这种情况的位置下标。为什么？

因为**两个奇数次的位置中间，一定出现偶数次**！！

**2. 那么现在的问题是：有没有一个"key"代表从 0~当前位置 各个元音出现次数的状态，然后一个"map"来保存各个状态最早出现的下标？**

如果有，那么我们就可以在遍历字符串过程中去计算结果：

（1）计算当前状态key

（2）判断map中是否出现过这个key，
如果没有，意味着以当前位置结束的最优解就是0，比如字符串"a"。
如果有，最优解就是 i（当前位置） - map[key]（最早出现该状态位置）

（3）将当前位置最优解和前面位置最优解比较得出最大值，就是题目的解

**3. key解析**

题目要求是出现偶数次还是奇数次，并不关心出现次数是多少，正好是两个状态，此时，我们可以利用二进制来表示，出现偶数次，用 0 表示，奇数次，用 1。如：

a，e，i，o，u 分别出现 1,1,1,2,0 次时，这个二进制数为 11100

用 0 表示偶数的好处是，0次也是偶数，这样起始位置就可以用二进制 00000 表示。

此时很明显，key 就是一个 0（00000） ～ 31（11111） 的数字

**4. map解析**

既然key是一个数字，map以数组来表示就最方便不过了，以各个状态为下标，值就是最早出现的位置

### 代码实现

```js
function findTheLongestSubstring (s) {
  // 为什么是左移 5 位？
  // 左移4位最大值是够用，但是左移之后还得补1，麻烦
  // 左移5位，确实有一位是多余的
  // 
  // 状态机。保留各个状态首次出现位置的后一项下标，-1表示未出现过
  // 
  // 为什么要保留后一项下标？
  // 因为在开始循环之前，元音都没有出现，是满足状态 "00000" 的，但是此时的下标 -1 和未出现冲突
  // 注意在计算结果时 +1
  const map = new Array(1 << 5).fill(-1) 
  // 0 表示全部未出现过的状态。显然，全部未出现过最早的时候就是起始位置
  map[0] = 0
  // 这是一个二进制表示的数 "11111" 分别代表 "u","o","i","e","a"出现了奇数次。用 0 代表出现偶数次
  // 注意，这个状态在每个循环中共享。
  let status = 0
  let ans = 0

  for (let i = 0; i < s.length; i++) {
    const char = s[i]
    // 根据上次结果计算当前状态
    // 异或计算特点：与 0 计算，保留当前位；与 1 计算，当前为取反。
    if (char === 'a') {
      status ^= 1 << 0
    } else if (char === 'e') {
      status ^= 1 << 1
    } else if (char === 'i') {
      status ^= 1 << 2
    } else if (char === 'o') {
      status ^= 1 << 3
    } else if (char === 'u') {
      status ^= 1 << 4
    }
    // 如果不是元音，状态不变

    // 为什么之前出现过就可以去计算更新结果？
    // 
    // 假设我们现在状态是 a,e 都出现了奇数次，那么对于当前下标来说，最大解就是当前下标 - 最早出现这个状态的下标
    // 因为两个出现奇数次的中间，一定出现偶数次
    if (map[status] !== -1) { // 之前出现过
      ans = Math.max(ans, i - map[status] + 1)
    } else {
      map[status] = i + 1
    }
  }

  return ans
};
```
