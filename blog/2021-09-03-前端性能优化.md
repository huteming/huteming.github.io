---
title: 前端性能优化
tags: [性能优化]
---

记录一下前端性能优化的一些方式。

<!--truncate-->

## 构建打点

**[speed-measure-webpack-plugin](https://www.npmjs.com/package/speed-measure-webpack-plugin)**

它能够测量出在你的构建过程中，每一个 Loader 和 Plugin 的执行时长，官方给出的效果图是下面这样：

![speed-measure-webpack-plugin](/img/blog/webpack/speed-measure-webpack-plugin.png)

## 构建阶段

四个大方向入手：缓存、多核、抽离以及拆分

### 缓存

**[babel-loader](https://www.npmjs.com/package/babel-loader)**

将 `loader` 的编译结果写入硬盘缓存，再次构建如果文件没有发生变化则会直接拉取缓存。可以通过设置 `cacheDirectory` 来开启缓存。

**[cache-loader](https://www.npmjs.com/package/cache-loader)**

它所做的事情，就是 babel-loader 开启 cache 后做的事情

**[uglifyjs-webpack-plugin](https://www.npmjs.com/package/uglifyjs-webpack-plugin)**

代码压缩阶段，也可以通过缓存解决大部分问题。我们可以通过开启 `cache` 配置开启我们的缓存功能，也可以通过开启 `parallel` 开启多核编译功能。

代码示例：

```js
module.exports = {
  optimization: {
    minimizer: [
      new UglifyJsPlugin({
        cache: true,
        parallel: true,
      }),
    ],
  },
};
```

### 多核构建

**[happypack](https://www.npmjs.com/package/happypack)**

其实对于一些编译代价昂贵的 `webpack` 插件，一般都会提供 `parallel` 这样的配置项供你开启多核编译。所以也不一定是需要 `happypack`，这就需要我们多去看看官网了

**可能碰到的问题**

在 `production` 模式下因为一个插件 `mini-css-extract-plugin`，可能会碰到这么两个问题：

1. `MiniCssExtractPlugin` 无法与 `happypack` 共存，如果用 `happypack` 对 `MiniCssExtractPlugin` 进行包裹，就会触发这个问题：[issue](https://github.com/amireh/happypack/issues/242)

2. `MiniCssExtractPlugin` 必须置于 `cache-loader` 执行之后，否则无法生效，参考 [issue](https://github.com/webpack-contrib/cache-loader/issues/40)。

所以最后，在 production 模式下的 CSS Rule 配置就变成了下面这样：

```js
module.exports = {
  ...,
  module: {
      rules: [
          ...,
          {
              test: /\.css$/
              exclude: /node_modules/,
              use: [
                  _mode === 'development' ? 'style-loader' : MiniCssExtractPlugin.loader,
                  'happypack/loader?id=css'
              ]
          }
      ]
  },
  plugins: [
      new HappyPack({
        id: 'css',
        threadPool: happyThreadPool,
        loaders: [
          'cache-loader',
          'css-loader',
          'postcss-loader',
        ],
      }),
  ],
}
```

### 抽离

对于一些不常变更的静态依赖，比如我们项目中常见的 React 全家桶、lodash 等等，我们不希望这些依赖被集成进每一次构建逻辑中，因此，我们会设法将这些静态依赖从每一次的构建逻辑中抽离出去，以提升我们每次构建的构建效率。

常见的方案有两种

1. [webpack-dll-plugin](https://webpack.docschina.org/plugins/dll-plugin/)

在首次构建时候就将这些静态依赖单独打包，后续只需要引用这个早就被打好的静态依赖包即可，有点类似“预编译”的概念

2. [externals](https://webpack.docschina.org/configuration/externals/)

我们将这些不需要打包的静态资源从构建逻辑中剔除出去，而使用 CDN 的方式，去引用它们。

### 拆分

**入口拆分**

在一个多页应用中，有多个 `entry` 的前提下，有时候我们只是更改了一个 `entry` 下的文件，但是却要对所有 `entry` 执行一遍构建，优化方案

1. 每一个子模块都被拆分成了一个单独的仓库中，单独构建

2. 集群编译

:::tip 集群编译

这里的集群当然不是指我们的真实物理机，而是我们的 docker。其原理就是将单个 entry 剥离出来维护一个独立的构建流程，并在一个容器内执行，待构建完成后，将生成文件打进指定目录。

为什么能这么做呢？因为我们知道，webpack 会将一个 entry 视为一个 chunk，并在最后生成文件时，将 chunk 单独生成一个文件，

:::

## 构建分析

**输出 Webpack 构建信息的.json 文件**

```cli
webpack --profile --json > stats.json
```

**web 可视化查看构建分析**

1. 通过可视化分析工具，是个在线 Web 应用，上传 stats.json 文件就可以

- [Webpack Analyse](http://webpack.github.io/analyse/)

- [Webpack Chart](http://alexkuz.github.io/webpack-chart/)

2. 安装[Webpack Bundle Analyzer](https://www.npmjs.com/package/webpack-bundle-analyzer)

## 其他

**[progress-bar-webpack-plugin](https://www.npmjs.com/package/progress-bar-webpack-plugin)**

能为你展示构建进度的 Plugin。效果图：

![progress-bar-webpack-plugin](/img/blog/webpack/progress-bar-webpack-plugin.webp)

**[webpack-build-notifier](https://www.npmjs.com/package/webpack-build-notifier)**

在你构建完成时，能够像微信、Lark 这样的 APP 弹出消息的方式，提示你构建已经完成了。效果图：

![webpack-build-notifier](/img/blog/webpack/webpack-build-notifier.webp)

**[webpack-dashboard](https://www.npmjs.com/package/webpack-dashboard)**

如果你对 webpack 原始的构建输出不满意的话，也可以使用这样一款 Plugin 来优化你的输出界面。效果图

![webpack-dashboard](/img/blog/webpack/webpack-dashboard.png)
