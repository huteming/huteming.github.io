---
title: React 生命周期
tags: [react]
draft: true
---

这里来记录下 React 的几个阶段的生命周期钩子。不过，看官方的[文档](https://zh-hans.reactjs.org/docs/react-component.html#the-component-lifecycle)可能来的更加直接。

<!--truncate-->

## 挂载

当组件实例被创建并插入 DOM 中时。

### constructor

```js
constructor(props)
```

可以做组件的初始化工作，比如说可以初始化 state，在 constructor 中可以直接修改 state，使用 this.state 进行赋值，**不能使用 this.setState 方法**

### componentWillMount

```js
componentWillMount()
```

:::caution 注意
在 v16.3 版本之后被列为即将过时，同时引入新的别名: **UNSAFE_componentWillMount**。官方的版本计划[在这里](https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
:::

在挂载之前被调用。它在 render() 之前调用，因此在此方法中**同步调用 setState() 不会触发额外渲染**。通常，我们建议使用 constructor() 来初始化 state。

:::note
如果一个组件中同时存在 componentWillMount 和 getDerivedStateFromProps，这时 componentWillMount 将不再执行，且在控制台会报异常提醒你应该删除 componentWillMount。

测试版本: 16.14.0
:::

### getDerivedStateFromProps

```js
static getDerivedStateFromProps(props, state)
```

会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。

请注意，不管原因是什么，都会在每次渲染前触发此方法。这与 `componentWillReceiveProps` 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 setState 时。

附: [官方说明](https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops)

### render

```js
render()
```

render() 方法是 class 组件中唯一必须实现的方法。

render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。

**如果 shouldComponentUpdate() 返回 false，则不会调用 render()**。

### componentDidMount

```js
componentDidMount()
```

componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。

你可以在 componentDidMount() 里**直接调用 setState()**。它将触发额外渲染，但此**渲染会发生在浏览器更新屏幕之前**。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。

如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理

## 更新

当组件的 props 或 state 发生变化时会触发更新。

### componentWillReceiveProps

```js
componentWillReceiveProps(nextProps)
```

:::caution 注意
在 v16.3 版本之后被列为即将过时，同时引入新的别名: **UNSAFE_componentWillReceiveProps**。官方的版本计划[在这里](https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
:::

`componentWillReceiveProps()` 会在已挂载的组件接收新的 props 之前被调用。如果你需要更新状态以响应 prop 更改（例如，重置它），你可以比较 this.props 和 nextProps 并在此方法中使用 this.setState() 执行 state 转换。

请注意，如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。

在挂载过程中，React 不会针对初始 props 调用 `componentWillReceiveProps()`。组件只会在组件的 props 更新时调用此方法。调用 `this.setState()` 通常不会触发 `componentWillReceiveProps()`。

附: [官方介绍](https://zh-hans.reactjs.org/docs/react-component.html#unsafe_componentwillreceiveprops)

### componentWillUpdate

```js
componentWillUpdate(nextProps, nextState)
```

:::caution 注意
在 v16.3 版本之后被列为即将过时，同时引入新的别名: **UNSAFE_componentWillUpdate**。官方的版本计划[在这里](https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
:::

当组件收到新的 props 或 state 时，会在渲染之前调用 componentWillUpdate()。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。

注意，你**不能此方法中调用 this.setState()**；在 componentWillUpdate() 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新

通常，此方法可以替换为 componentDidUpdate()。如果你在此方法中读取 DOM 信息（例如，为了保存滚动位置），则可以将此逻辑移至 getSnapshotBeforeUpdate() 中。

:::caution 注意
如果 shouldComponentUpdate() 返回 false，则不会调用 componentWillUpdate()。
:::

:::note
如果一个组件中同时存在 componentWillUpdate 和 getDerivedStateFromProps，这时 componentWillUpdate 将不再执行，且在控制台会报异常提醒你应该删除 componentWillUpdate

测试版本: 16.14.0
:::

### getDerivedStateFromProps

和**挂载**期间的 [getDerivedStateFromProps](#getderivedstatefromprops) 一致。

### shouldComponentUpdate

```js
shouldComponentUpdate(nextProps, nextState)
```

当 props 或 state 发生变化时，`shouldComponentUpdate()` 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 `forceUpdate()` 时不会调用该方法。

如果 shouldComponentUpdate() 返回 false，则不会调用 `UNSAFE_componentWillUpdate()`，`render()` 和 `componentDidUpdate()`。

此方法仅作为**性能优化的方式**而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该**考虑使用内置的 PureComponent 组件**，而不是手动编写 `shouldComponentUpdate()`。`PureComponent` 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。

附: [官方说明](https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate)

### render

和**挂载**期间的 [render](#render) 一致。

### getSnapshotBeforeUpdate

`getSnapshotBeforeUpdate()` 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期方法的任何返回值将作为参数传递给 `componentDidUpdate()`。

附: [官方介绍](https://zh-hans.reactjs.org/docs/react-component.html#getsnapshotbeforeupdate)

### React 更新 ­D­O­M 和 refs

这并不是什么生命周期的钩子，只是 React 内部在执行更新。放这里只是为了直观了解 React 各个阶段的相对顺序。

### componentDidUpdate

```js
componentDidUpdate(prevProps, prevState, snapshot)
```

`componentDidUpdate()` 会在更新后会被立即调用。首次渲染不会执行此方法。

当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。

```js
componentDidUpdate(prevProps) {
  // 典型用法（不要忘记比较 props）：
  if (this.props.userID !== prevProps.userID) {
    this.fetchData(this.props.userID);
  }
}
```

你也可以在 `componentDidUpdate()` 中**直接调用 setState()**，但请注意它**必须被包裹在一个条件语句里**，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。

:::caution 注意
如果 `shouldComponentUpdate()` 返回值为 false，则不会调用 `componentDidUpdate()`。
:::

## 卸载

当组件从 DOM 中移除时会调用。

### componentWillUnmount

```js
componentWillUnmount()
```

`componentWillUnmount()` 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 `componentDidMount()` 中创建的订阅等。

`componentWillUnmount()` 中**不应调用 `setState()`**，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。

## 错误处理

当渲染过程，生命周期，或子组件的构造函数中抛出错误时会调用。

:::note
`ErrorBoundary` **只能捕获子组件的 render 错误**，有一定的局限性，以下是无法处理的情况:

- 事件处理函数（比如 onClick,onMouseEnter)
- 异步代码（如 requestAnimationFrame，setTimeout,promise)
- 服务端渲染
- ErrorBoundary 组件本身的错误。

:::

### getDerivedStateFromError

```js
static getDerivedStateFromError(error)
```

此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显降级 UI
    return { hasError: true }
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级  UI
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }
}
```

:::tip
主要用在发生渲染错误时进行 UI 降级处理
:::

### componentDidCatch

```js
componentDidCatch(error, info)
```

此生命周期在后代组件抛出错误后被调用。 它接收两个参数：

1. error —— 抛出的错误。
2. info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。

`componentDidCatch()` 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：

```js
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error) {
    // 更新 state 使下一次渲染可以显示降级 UI
    return { hasError: true }
  }

  componentDidCatch(error, info) {
    // "组件堆栈" 例子:
    //   in ComponentThatThrows (created by App)
    //   in ErrorBoundary (created by App)
    //   in div (created by App)
    //   in App
    logComponentStackToMyService(info.componentStack)
  }

  render() {
    if (this.state.hasError) {
      // 你可以渲染任何自定义的降级 UI
      return <h1>Something went wrong.</h1>
    }

    return this.props.children
  }
}
```

React 的开发和生产构建版本在 `componentDidCatch()` 的方式上有轻微差别。

在开发模式下，错误会冒泡至 window，这意味着任何 `window.onerror` 或 `window.addEventListener('error', callback)` 会中断这些已经被 `componentDidCatch()` 捕获的错误。

相反，在生产模式下，错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 `componentDidCatch()` 捕获的错误。

:::tip
主要用在做日志记录
:::
